#!/usr/bin/env raku

# use Grammar::Tracer;

sub get-twiki-author(Str $author) {
    given $author {
        when /^[ $<first>=(<[A..Z]> <[a..z]>+) $<last>=(<[A..Z]> <[A..Z a..z]>+) ]$/ {
            ~$/<first> ~ ' ' ~ ~$/<last>.tclc
        }

        when /^[ TWiki\w+ | BaseUserMapping_\d+ ]$/ {
            'TWiki Pseudo User'
        }

        default {
            note "Unexpected page author: { $author }";
            $author
        }
    }
}

sub get-name-from-twiki-file(Str $file) {
    $file.IO
        .basename
        .subst(/'.txt' $/)
}

sub get-title-from-twiki-file(Str $file) {
    get-name-from-twiki-file($file)
        .subst(/(<[a..z]>) (<[A..Z]>)/, { "$0 $1" }, :g)
}

grammar TWiki::Grammar {
    token TOP {
        <metainfo>

        \n*

        <paragraph>*
    }

    token metainfo {
        <topic-info>
        <topic-parent>?
    }

    token topic-info {
        ^^ '%META:TOPICINFO{' <metavar>+ % ' ' '}%' \n
    }

    token topic-parent {
        ^^ '%META:TOPICPARENT{' <metavar> '}%' \n
    }

    token metavar {
        $<name>=[\w+] '="' ~ '"' $<value>=[<-["]>*]
    }

    token paragraph {
        (
            # We have to use "|" here because separators and headers start in
            # the same way.
            || [ <separator> | <header> ]
            || <.signature>
            || <block-image>
            || <list-items>
            || <html-fragment>
            || <table>
            || <.attachment>
            || <.ignored-meta>
            || <normal-text>
        )

        [ \n+ || $ ]
    }

    token separator {
        ^^ '-' ** 3..*
    }

    token header {
        ^^ '-' ** 3..4
        [
            || $<level>=['+' ** 1..5] ' '? <text-span>?
            || { die "Incorrect header syntax near position { $/.pos() + 5 }" }
        ]
    }

    token attribute {
        # This definition of value doesn't allow using quotes of the other
        # kind inside the attribute value, which is allowed in theory, but is
        # not needed in practice, and it's much simpler to forbid it.
        $<name>=[\w+] '=' $<quote>=<['"]> ~ $<quote> $<value>=<-['"]>+
    }

    token block-image {
        ^^ <.ws> '<img ' ~ ' />' [ <attribute>+ % ' ' ]
    }

    token list-indent {
        '   '
    }

    token list-items {
        ^^ <.list-indent> <!before \s>
        <list-item>
        [\n <.list-indent> <list-item>]*
    }

    token list-item {
        (
            || <list-bullet>
            || <list-numbered>
            || <list-def>
            || { die "Incorrect list item syntax near position { $/.pos() + 3 }" }
        )
    }

    # List item text can wrap on the following line if it starts by 3 spaces,
    # but we shouldn't match the following item here.
    token list-text {
        <.text-span> [ \n <.list-indent> <-[* 1..9 A a $]> <.text-span>+ ]*
    }

    token list-bullet {
        # There are some (useless) empty list items in the existing pages, so
        # allow them.
        '* ' <list-text>?
    }

    token list-numbered {
        # Period is supposed to be mandatory here but in practice can be (and
        # is) omitted. OTOH we don't support Roman numerals of numbering nor
        # any other Latin letters because this is not used in the existing
        # pages.
        <[1..9 A a]> '.'? ' ' <list-text>
    }

    token list-def {
        '$ ' $<name>=<-[:\n]>+ ': ' $<text>=<.list-text>
    }

    # This is only good for non-nested tags, of course, but, luckily, this is
    # mostly the case.
    token html-tag(Str $tag) {
        "<$tag" .+? "</$tag>"
    }

    token html-comment {
        '<!--' .+? '->'
    }

    token html-fragment {
        ^^
        [
            || <html-tag: 'table'> <.ws> <html-tag: 'div'>?
            || [ <html-tag: 'div'> <.ws> ]+ <.html-comment>?
            || <html-tag: 'form'>
        ]
    }

    token table {
        ^^ '|'
        [
            || [ <header-row> || <table-row> ] \n
               [ '|' <table-row> ]* % \n
            || { die "Incorrect table syntax near position { $/.pos() + 3 }" }
        ]
    }

    # Redefine the default ws to _not_ include vertical whitespace such as \n.
    token ws {
        \h*
    }

    token header-row {
        [ <.ws> <header-cell>? '|' ]+ <.ws>
    }

    token header-cell {
        '*' $<value>=<-[*|\n]>+ '*' <.ws>
    }

    token table-row {
        <.ws> [ $<cell>=<-[|\n]>* '|' ]+ <.ws>
    }

    token text-span {
        (
            || <verbatim>
            || <plain-text>
        )+
    }

    # This is almost like html-tag but is used for TWiki-specific tags too and
    # captures its contents (and doesn't allow attributes for the opening tag).
    token capture-tag(Str $tag) {
        "<$tag>" \n* $<contents>=.+? \n? "</$tag>" \h*
    }

    token verbatim {
        <capture-tag: 'verbatim'>
    }

    # TODO: exclude all markup characters: *_=<![
    token plain-text {
        <-[\n]>+
    }

    token signature-date {
        \d ** 1..2 ' ' \w ** 3..4 ' ' \d ** 4
    }

    token signature-date-ISO {
        \d ** 4 '-' \d ** 2 '-' \d ** 2
    }

    token signature {
        ^^ '-- Main.'
        [
            || $<author-in-signature>=[\w+] ' - '
            [
                || 'last update '
                || 'Created ' <.signature-date> ' - ' [ 'Updated ' || 'Last modified ' ]
            ]?
            [ <.signature-date> || <.signature-date-ISO> ]
            [
                || ' <br/>'
                || ' -- Main.' \N+
                || ' - ' \N+
            ]?
            <.ws>
            || { die "Incorrect signature line syntax at { $/.pos() }" }
        ]
    }

    token attachment {
        ^^ '%META:FILEATTACHMENT{'
        [
            || <metavar>+ % ' ' '}%'
            || { die "Incorrect FILEATTACHMENT syntax near position { $/.pos() + 3 }" }
        ]
    }

    token ignored-meta {
        ^^ '%META:'
        [
            || [ FORM || FIELD || PREFERENCE || TOPICMOVED ] '{'  \N+? '}%'
            || { die "Unknown %META directive near position { $/.pos() + 5 }" }
        ]
    }

    token normal-text {
        ^^ <text-span>
    }
}

class TWiki::Metainfo {
    has $.file;
    has $.author;
    has Instant $.date;
    has $.parent;

    method to-adoc() {
        qq:to/END/;
        = { get-title-from-twiki-file($.file) }
        :author: $.author
        :revdate: { $.date.DateTime }
        END
    }
}

class TWiki::Verbatim {
    has $.text;

    method to-adoc() {
        # Always insert a new line before the start of a block, but don't add
        # extra new lines otherwise, as the text already (may) contain(s) them.
        qq:to/END/;

        ....
        $.text
        ....
        END
    }
}

class TWiki::PlainText {
    has $.text;

    method new(Str $text) {
        self.bless(:$text)
    }

    method to-adoc() {
        $.text
    }
}

class TWiki::Image {
    has $.src;
    has $.alt;
    has $.width;
    has $.height;

    method to-adoc() {
        my $extra_attrs = '';
        if $.width || $.height {
            $extra_attrs = ",$.width,$.height"
        }

        "image::{$.src}[{$.alt}{$extra_attrs}]"
    }
}

class TWiki::BulletListItem {
    has $.text;

    method to-adoc() {
        # A lone "*" isn't recognized as a list item, so ensure that we always
        # use a non-empty text.
        "* { $.text || '&nbsp;'}"
    }
}

class TWiki::NumberedListItem {
    has $.text;

    method to-adoc() {
        ". $.text"
    }
}

class TWiki::DefListItem {
    has $.name;
    has $.text;

    method to-adoc() {
        "{$.name}:: $.text"
    }
}

class TWiki::List {
    has @.items;

    method to-adoc() {
        join("\n", @.items».to-adoc) ~ "\n"
    }
}

class TWiki::HTMLFragment {
    has $.html is rw;

    method to-adoc() {
        qq:to/END/;
        ++++
        $.html
        ++++
        END
    }
}

class TWiki::Separator is TWiki::HTMLFragment {
    submethod TWEAK {
        self.html = '<hr>';
    }
}

class TWiki::Header {
    has Int $.level;
    has Str $.text;

    method to-adoc() {
        '=' x ($.level + 1) ~ ' ' ~ $.text ~ "\n"
    }
}

class TWiki::TableRow {
    has Str @.cells;

    method to-adoc() {
        '|' ~ join '|', @.cells
    }
}

class TWiki::Table {
    has Str @.headers;
    has @.rows;

    method to-adoc() {
        my ($num-columns, $headers-attr, $headers-row);
        if @.headers {
            $num-columns = @.headers.elems;
            $headers-attr = '%header,';
            $headers-row = '|' ~ join('|', @.headers) ~ "\n";
        } else {
            $num-columns = @.rows[0].elems;
            $headers-attr = '';
            $headers-row = '';
        }

        qq:to/END/;
        [cols="{ $headers-attr }{ join ',', '1' xx $num-columns }"]
        |===
        { $headers-row }{ join "\n", @.rows».to-adoc }
        |===
        END
    }
}

class TWiki::Text {
    has @.elements;

    method to-adoc() {
        @.elements».to-adoc.join ~ "\n"
    }
}

class TWiki::Page {
    has TWiki::Metainfo $.metainfo;
    has @.body;

    method to-adoc() {
        join "\n", $.metainfo.to-adoc, @.body».to-adoc
    }
}

class TWiki::Actions {
    has $.file;

    method TOP($/) {
        # Get rid of paragraphs without any corresponding AST node.
        my @paragraphs;
        for $/<paragraph> {
            my $ast = $_.ast;

            # Somehow we end up with lists containing a single element and not
            # just the element itself here.
            if $ast.elems > 1 {
                note "Unexpected AST structure when parsing $.file: { $ast.perl }";
                next
            }

            # We also may have an empty list, but this is fine, just skip it.
            next unless $ast.elems;

            my $value = $ast[0];

            # Some AST nodes don't have any value associated with them, this
            # is fine too, just skip them.
            next unless defined $value;

            @paragraphs.push($value);
        }

        make TWiki::Page.new(
            metainfo => $<metainfo>.ast,
            body     => @paragraphs,
        );
    }

    method metainfo($/) {
        my $info = $/<topic-info>.ast;
        my $parent = $/<topic-parent>;
        make TWiki::Metainfo.new(
            file   => $.file,
            author => $info<author>,
            date   => $info<date>,
            parent => $parent ?? ~$parent.ast !! Nil,
        );
    }

    method topic-info($/) {
        my $author;
        my $date;
        for $/<metavar> {
            my $var = $_.ast;
            given $var.key {
                when 'author' { $author = get-twiki-author($var.value) }
                when 'date' { $date = Instant.from-posix: $var.value }
                when 'format' | 'version' | 'reprev' { }
                default { note "In $.file: unknown metavar { $var.key } = { $var.value }" }
            }
        }

        die "Required author metavar not found."
            unless defined($author);
        die "Required date metavar not found."
            unless defined($date);

        make { author => $author, date => $date }
    }

    method topic-parent($/) {
        my $parent = $/<metavar>;
        die "Found $parent<name> instead of the expected name attribute in META:TOPICPARENT."
            unless $parent<name> eq 'name';

        make $parent<value>;
    }

    method metavar($/) {
        make ~$/<name> => ~$/<value>;
    }

    method paragraph($/) {
        make $/[0].hash.values».ast;
    }

    method separator($/) {
        make TWiki::Separator.new;
    }

    method attribute($/) {
        make ~$/<name> => ~$/<value>;
    }

    method verbatim($/) {
        make TWiki::Verbatim.new(
            text => ~$<capture-tag><contents>
        );
    }

    method plain-text($/) {
        make TWiki::PlainText.new(~$/);
    }

    method block-image($/) {
        my %attributes;
        %attributes.append: $<attribute>.list».ast;

        make TWiki::Image.new(
            | %attributes
        );
    }

    method list-items($/) {
        make TWiki::List.new(
            items => $/<list-item>».ast
        );
    }

    method list-item($/) {
        # The matches hash here contains just a single element because it's an
        # alternative, so take it.
        make $/[0].hash.values[0].ast;
    }

    method list-bullet($/) {
        # As mentioned in the grammar, there are some empty lists, accept them
        # without complaining.
        my $text = $<list-text> // '';
        make TWiki::BulletListItem.new(
            text => ~$text
        );
    }

    method list-numbered($/) {
        make TWiki::NumberedListItem.new(
            text => ~$<list-text>
        );
    }

    method list-def($/) {
        make TWiki::DefListItem.new(
            name => ~$<name>,
            text => ~$<text>,
        );
    }

    method html-fragment($/) {
        make TWiki::HTMLFragment.new(
            html => ~$/
        );
    }

    method header($/) {
        # Header may not have any text, making it rather useless, so skip it.
        my $text = $/<text-span>;
        return unless $text;

        make TWiki::Header.new(
            level => $/<level>.chars,
            text  => ~$text
        );
    }

    method header-row($/) {
        make $/<header-cell>».ast;
    }

    method header-cell($/) {
        # There are some empty header cells too.
        my $text = $/<value>;
        make $text ?? ~$text !! '';
    }

    method table-row($/) {
        make TWiki::TableRow.new(
            cells => $/<cell>».Str
        );
    }

    method table($/) {
        make TWiki::Table.new(
            headers => defined($/<header-row>) ?? $/<header-row>.ast !! [],
            rows    => $/<table-row>».ast
        );
    }

    method text-span($/) {
        # Text span contains a single multiple match represented by an array
        # whose elements are single-element hashes, so flatten them.
        #
        # The grammar structure probably could (should?) be reorganized to
        # simplify this.
        my @elements;
        for $/[0] -> $single-element {
            my $span = $single-element.hash.values;
            if $span.elems != 1 {
                note "Unexpected span AST structure when parsing $.file: { $span.perl }";
            }

            @elements.push: $span[0].ast;
        }

        make @elements;
    }

    method normal-text($/) {
        make TWiki::Text.new(
            elements => $<text-span>.ast
        );
    }
}

sub MAIN(*@twiki-files, Str :$out-dir, Bool :$debug) {
    # Process command-line arguments and read the input files.
    sub log-debug($msg) {
        note $msg if $debug;
    }

    if $out-dir {
        $out-dir.IO.mkdir;
    }

    my $rc = 0;
    for @twiki-files -> $twiki-file {
        my $input = $twiki-file.IO.slurp;

        CATCH {
            default {
                note "Error while parsing $twiki-file: $_.";
                $rc = 2;
            }
        }

        my $actions = TWiki::Actions.new(file => $twiki-file);
        my $result = TWiki::Grammar.parse($input, :actions($actions)).ast;
        if ! $result {
            note "Failed to parse $twiki-file as TWiki page.";
            $rc = 1;
        } else {
            log-debug $result;

            if $out-dir {
                $out-dir.IO.add(
                    get-name-from-twiki-file($twiki-file) ~ '.adoc'
                ).spurt: $result.to-adoc
            }
        }
    }

    exit $rc
}
