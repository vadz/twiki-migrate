#!/usr/bin/env raku

# use Grammar::Tracer;

sub get-twiki-author(Str $author) {
    given $author {
        when /^[ $<first>=(<[A..Z]> <[a..z]>+) $<last>=(<[A..Z]> <[A..Z a..z]>+) ]$/ {
            ~$/<first> ~ ' ' ~ ~$/<last>.tclc
        }

        when /^[ TWiki\w+ | BaseUserMapping_\d+ ]$/ {
            'TWiki Pseudo User'
        }

        default {
            note "Unexpected page author: { $author }";
            $author
        }
    }
}

sub get-name-from-twiki-file(Str $file) {
    $file.IO
        .basename
        .subst(/'.txt' $/)
}

sub get-title-from-twiki-file(Str $file) {
    get-name-from-twiki-file($file)
        .subst(/(<[a..z]>) (<[A..Z]>)/, { "$0 $1" }, :g)
}

grammar TWiki::Grammar {
    token TOP {
        <metainfo>

        \n*

        <paragraph>*
    }

    token metainfo {
        <topic-info>
        <topic-parent>?
    }

    token topic-info {
        ^^ '%META:TOPICINFO{' <metavar>+ % ' ' '}%' \n
    }

    token topic-parent {
        ^^ '%META:TOPICPARENT{' <metavar> '}%' \n
    }

    token metavar {
        $<name>=[\w+] '="' ~ '"' $<value>=[<-["]>*]
    }

    token paragraph {
        (
            # We have to use "|" here because separators and headers start in
            # the same way.
            || [ <separator> | <header> ]
            || <.signature>
            || <block-image>
            || <list-items>
            || <html-fragment>
            || <table>
            || <.attachment>
            || <.ignored-meta>
            || <normal-text>
        )

        [ \n+ || $ ]
    }

    token separator {
        ^^ '-' ** 3..*
    }

    token header {
        ^^ '-' ** 3..4
        [
            || $<level>=['+' ** 1..5] ' '? <text-span>?
            || { die "Incorrect header syntax near position { $/.pos() + 5 }" }
        ]
    }

    token attribute {
        # This definition of value doesn't allow using quotes of the other
        # kind inside the attribute value, which is allowed in theory, but is
        # not needed in practice, and it's much simpler to forbid it.
        $<name>=[\w+] '=' $<quote>=<['"]> ~ $<quote> $<value>=<-['"]>+
    }

    token block-image {
        ^^ <.ws> '<img ' ~ ' />' [ <attribute>+ % ' ' ]
    }

    # In principle, only spaces are allowed. but some of the existing pages
    # use TABs, so we have to accept them too.
    token list-indent(Int $level) {
        <list-space-indent: $level> || <list-tab-indent: $level>
    }

    # Also, just <...>**$level doesn't work, so use a code block.
    token list-space-indent(Int $level) {
        '   '+ <?{ $/.chars div 3 == $level }>
    }

    token list-tab-indent(Int $level) {
        \t+ <?{ $/.chars == $level }>
    }

    token list-items(Int $level = 1) {
        ^^ <list-indent: $level> <!before \s>
        $<item>=<list-item: $level>
        [
            || \n $<item>=<list-items: $level + 1>
            || \n <.list-indent: $level> $<item>=<list-item: $level>
        ]*
    }

    token list-item(Int $level) {
        (
            || <list-bullet: $level>
            || <list-numbered: $level>
            || <list-def: $level>
            || { die "Incorrect level $level list syntax near position { $/.pos() + 3 }" }
        )
    }

    # List item text can wrap on the following line if it starts by just a
    # single indent (even for a nested list!), but we shouldn't match the
    # following item here.
    token list-text(Int $level) {
        <text-span> [ \n <.list-indent: 1> <-[* 1..9 A a $]> <text-span>+ ]*
    }

    token list-bullet(Int $level) {
        # There are some (useless) empty list items in the existing pages, so
        # allow them.
        '* ' <list-text: $level>?
    }

    token list-numbered(Int $level) {
        # Period is supposed to be mandatory here but in practice can be (and
        # is) omitted. OTOH we don't support Roman numerals of numbering nor
        # any other Latin letters because this is not used in the existing
        # pages.
        <[1..9 A a]> '.'? ' ' <list-text: $level>
    }

    token list-def(Int $level) {
        '$ ' $<name>=<-[:\n]>+ ': ' $<text>=<.list-text: $level>
    }

    # This is only good for non-nested tags, of course, but, luckily, this is
    # mostly the case.
    token html-tag(Str $tag) {
        "<$tag" .+? "</$tag>"
    }

    token html-comment {
        '<!--' .+? '->'
    }

    token html-fragment {
        ^^
        [
            || <html-tag: 'table'> <.ws> <html-tag: 'div'>?
            || [ <html-tag: 'div'> <.ws> ]+ <.html-comment>?
            || <html-tag: 'form'>
        ]
    }

    token table {
        ^^
        [ '%TABLE{ ' <.metavar>+ % ' ' ' }%' \n ]?
        '|'
        [
            || [ <header-row> || <table-row> ] \n
               [ '|' <table-row> ]* % \n
            || { die "Incorrect table syntax near position { $/.pos() + 3 }" }
        ]
    }

    # Redefine the default ws to _not_ include vertical whitespace such as \n.
    token ws {
        \h*
    }

    # This is our own token, unlike <ws>.
    token space {
        \h+
    }

    token header-row {
        [ <.ws> <header-cell>? '|' ]+ <.ws>
    }

    token header-cell {
        '*' $<value>=<-[*|\n]>+ '*' <.ws>
    }

    token table-row {
        <.ws> [ $<cell>=<-[|\n]>* '|' ]+ <.ws>
    }

    token text-span {
        (
            || <space>
            || <verbatim>
            || <nop>
            || <br>
            || <strong>
            || <em>
            || <bold>
            || <bold-italic>
            || <italic>
            || <bold-fixed>
            || <fixed>
            || <span>
            || <normal-word>
        )+
    }

    # This is almost like html-tag but is used for TWiki-specific tags too and
    # captures its contents.
    token capture-tag(Str $tag) {
        "<$tag" [\h+ $<attributes>=<-[>]>+]? ">"
        \n*
        $<contents>=.+?
        \n?
        "</$tag>"
    }

    token verbatim {
        <capture-tag: 'verbatim'>
    }

    token nop {
        '<nop>'
    }

    token br {
        '<br />'
    }

    token strong {
        <capture-tag: 'strong'>
    }

    token em {
        <capture-tag: 'em'>
    }

    token bold {
        <!after \w> '*' $<text>=\N+? '*' <!before \w>
    }

    token bold-italic {
        « '__' $<text>=\N+? '__' »
    }

    token italic {
        # Don't take into account underscores appearing in the middle of the
        # words and do allow them in between those that bracket words.
        « '_' $<text>=\N+? '_' »
    }

    token bold-fixed {
        # Note that '=' should be allowed inside here, it can, and is, used.
        <!after \w> '==' $<text>=[ <-[=]>+ '=' <-[=]>+ ]+ '==' <!before \w>
    }

    token fixed {
        # We have to account for a completely pathological but existing case
        # of using '=' inside this one too when it goes until the end of line
        # (and it must come first as otherwise it would be never considered).
        [
            || '=' $<text>=[ <-[=]>+ '=' <-[=]>+ ]+ '=' $$
            || '=' $<text>=<-[=\n]>+ '='
        ]
    }

    # This one is special because span tags can be nested, but we only handle
    # the case of having only the nested span inside the outer one, as this is
    # the only thing which we seem to have in practice.
    token span {
        [
            || '<span' [\h+ <-[>]>+]? '>' \N*? '</span>'
        ]
    }

    # We need to allow "="s not at the start or end of the word (knowing that
    # the other ones will be consumed by <fixed> tried earlier) and "_" and
    # "*" inside the words (those preceded by the word boundaries should have
    # been consumed by <italic>).
    #
    # TODO: exclude ! and [ too when links are supported.
    token normal-word {
        || <-[<*_=\n]> <[\S] - [< = >]>*
        || <!wb> '=' <!wb>
        || <wb> '=' <wb>
        || <wb> '==' <wb>
    }

    token signature-date {
        \d ** 1..2 ' ' \w ** 3..4 ' ' \d ** 4
    }

    token signature-date-ISO {
        \d ** 4 '-' \d ** 2 '-' \d ** 2
    }

    token signature {
        ^^ '-- Main.'
        [
            || $<author-in-signature>=[\w+] ' - '
            [
                || 'last update '
                || 'Created ' <.signature-date> ' - ' [ 'Updated ' || 'Last modified ' ]
            ]?
            [ <.signature-date> || <.signature-date-ISO> ]
            [
                || ' <br/>'
                || ' -- Main.' \N+
                || ' - ' \N+
            ]?
            <.ws>
            || { die "Incorrect signature line syntax at { $/.pos() }" }
        ]
    }

    token attachment {
        ^^ '%META:FILEATTACHMENT{'
        [
            || <metavar>+ % ' ' '}%'
            || { die "Incorrect FILEATTACHMENT syntax near position { $/.pos() + 3 }" }
        ]
    }

    token ignored-meta {
        ^^ '%META:'
        [
            || [ FORM || FIELD || PREFERENCE || TOPICMOVED ] '{'  \N+? '}%'
            || { die "Unknown %META directive near position { $/.pos() + 5 }" }
        ]
    }

    token normal-text {
        ^^ <text-span>
    }
}

class TWiki::Metainfo {
    has $.file;
    has $.author;
    has Instant $.date;
    has $.parent;

    method to-adoc() {
        qq:to/END/;
        = { get-title-from-twiki-file($.file) }
        :author: $.author
        :revdate: { $.date.DateTime }
        END
    }
}

class TWiki::Verbatim {
    has $.text;

    method to-adoc() {
        # Always insert a new line before the start of a block, but don't add
        # extra new lines otherwise, as the text already (may) contain(s) them.
        qq:to/END/;

        ....
        $.text
        ....
        END
    }
}

class TWiki::Ignored {
    method to-adoc() {
        ''
    }
}

class TWiki::LineBreak {
    method to-adoc() {
        " +\n"
    }
}

class TWiki::FormattedText {
    has $.delimiter;
    has $.text;

    method to-adoc() {
        $.delimiter ~ $.text ~ $.delimiter.flip
    }
}

class TWiki::PlainText {
    has $.text;

    method new(Str $text) {
        self.bless(:$text)
    }

    method to-adoc() {
        $.text
    }
}

class TWiki::Image {
    has $.src;
    has $.alt;
    has $.width;
    has $.height;

    method to-adoc() {
        my $extra_attrs = '';
        if $.width || $.height {
            $extra_attrs = ",$.width,$.height"
        }

        "image::{$.src}[{$.alt}{$extra_attrs}]"
    }
}

class TWiki::BulletListItem {
    has $.text;

    method to-adoc(Int $level) {
        # As mentioned in the grammar, there are some empty lists, accept them
        # without complaining and, as a lone "*" isn't recognized as a list
        # item, ensure that we always use a non-empty text.
        '*' x $level ~ ' ' ~ ($.text ?? $.text.to-adoc !! '&nbsp;')
    }
}

class TWiki::NumberedListItem {
    has $.text;

    method to-adoc(Int $level) {
        '.' x $level ~ ' ' ~ $.text.to-adoc
    }
}

class TWiki::DefListItem {
    has $.name;
    has $.text;

    method to-adoc(Int $level) {
        note "Definition lists at level $level not supported." if $level != 1;
        "{$.name}:: { $.text.to-adoc }"
    }
}

class TWiki::List {
    has @.items;

    method to-adoc(Int $level = 0) {
        my $adoc = @.items».to-adoc($level + 1).join;

        # Separate top level lists with new lines.
        if $level == 0 {
            $adoc ~= "\n"
        }

        $adoc
    }
}

class TWiki::HTMLSpan {
    has $.html;

    method to-adoc() {
        "+++$.html+++"
    }
}

class TWiki::HTMLFragment {
    has $.html is rw;

    method to-adoc() {
        qq:to/END/;
        ++++
        $.html
        ++++
        END
    }
}

class TWiki::Separator is TWiki::HTMLFragment {
    submethod TWEAK {
        self.html = '<hr>';
    }
}

class TWiki::Header {
    has Int $.level;
    has $.text;

    method to-adoc() {
        '=' x ($.level + 1) ~ ' ' ~ $.text.to-adoc ~ "\n"
    }
}

class TWiki::TableRow {
    has Str @.cells;

    method to-adoc() {
        '|' ~ join '|', @.cells
    }
}

class TWiki::Table {
    has Str @.headers;
    has @.rows;

    method to-adoc() {
        my ($num-columns, $headers-attr, $headers-row);
        if @.headers {
            $num-columns = @.headers.elems;
            $headers-attr = '%header,';
            $headers-row = '|' ~ join('|', @.headers) ~ "\n";
        } else {
            $num-columns = @.rows[0].elems;
            $headers-attr = '';
            $headers-row = '';
        }

        qq:to/END/;
        [cols="{ $headers-attr }{ join ',', '1' xx $num-columns }"]
        |===
        { $headers-row }{ join "\n", @.rows».to-adoc }
        |===
        END
    }
}

class TWiki::Text {
    has @.elements;

    method to-adoc() {
        @.elements».to-adoc.join ~ "\n"
    }
}

class TWiki::Page {
    has TWiki::Metainfo $.metainfo;
    has @.body;

    method to-adoc() {
        join "\n", $.metainfo.to-adoc, @.body».to-adoc
    }
}

class TWiki::Actions {
    has $.file;

    method TOP($/) {
        # Get rid of paragraphs without any corresponding AST node.
        my @paragraphs;
        for $/<paragraph> {
            my $ast = $_.ast;

            # Somehow we end up with lists containing a single element and not
            # just the element itself here.
            if $ast.elems > 1 {
                note "Unexpected AST structure when parsing $.file: { $ast.perl }";
                next
            }

            # We also may have an empty list, but this is fine, just skip it.
            next unless $ast.elems;

            my $value = $ast[0];

            # Some AST nodes don't have any value associated with them, this
            # is fine too, just skip them.
            next unless defined $value;

            @paragraphs.push($value);
        }

        make TWiki::Page.new(
            metainfo => $<metainfo>.ast,
            body     => @paragraphs,
        );
    }

    method metainfo($/) {
        my $info = $/<topic-info>.ast;
        my $parent = $/<topic-parent>;
        make TWiki::Metainfo.new(
            file   => $.file,
            author => $info<author>,
            date   => $info<date>,
            parent => $parent ?? ~$parent.ast !! Nil,
        );
    }

    method topic-info($/) {
        my $author;
        my $date;
        for $/<metavar> {
            my $var = $_.ast;
            given $var.key {
                when 'author' { $author = get-twiki-author($var.value) }
                when 'date' { $date = Instant.from-posix: $var.value }
                when 'format' | 'version' | 'reprev' { }
                default { note "In $.file: unknown metavar { $var.key } = { $var.value }" }
            }
        }

        die "Required author metavar not found."
            unless defined($author);
        die "Required date metavar not found."
            unless defined($date);

        make { author => $author, date => $date }
    }

    method topic-parent($/) {
        my $parent = $/<metavar>;
        die "Found $parent<name> instead of the expected name attribute in META:TOPICPARENT."
            unless $parent<name> eq 'name';

        make $parent<value>;
    }

    method metavar($/) {
        make ~$/<name> => ~$/<value>;
    }

    method paragraph($/) {
        make $/[0].hash.values».ast;
    }

    method separator($/) {
        make TWiki::Separator.new;
    }

    method attribute($/) {
        make ~$/<name> => ~$/<value>;
    }

    method space($/) {
        make TWiki::PlainText.new(~$/);
    }

    method verbatim($/) {
        make TWiki::Verbatim.new(
            text => ~$<capture-tag><contents>
        );
    }

    method nop($/) {
        make TWiki::Ignored.new();
    }

    method br($/) {
        make TWiki::LineBreak.new();
    }

    method strong($/) {
        # Most occurrences of <strong> can be mapped to Asciidoc native bold
        # markup, but this tag can also be used with attributes, in which case
        # we need to preserve it as HTML.
        my $attributes = $<capture-tag><attributes>;

        $attributes
            ?? make TWiki::HTMLSpan.new(
                html => ~$/
            )
            !! make TWiki::FormattedText.new(
                delimiter => '*',
                text      => ~$<capture-tag><contents>
            );
    }

    method em($/) {
        make TWiki::FormattedText.new(
            delimiter => '_',
            text      => ~$<capture-tag><contents>
        );
    }

    method bold($/) {
        make TWiki::FormattedText.new(
            delimiter => '*',
            text      => ~$<text>
        );
    }

    method bold-italic($/) {
        make TWiki::FormattedText.new(
            delimiter => '*_',
            text      => ~$<text>
        );
    }

    method italic($/) {
        make TWiki::FormattedText.new(
            delimiter => '_',
            text      => ~$<text>
        );
    }

    method bold-fixed($/) {
        make TWiki::FormattedText.new(
            delimiter => '`*',
            text      => ~$<text>
        );
    }

    method fixed($/) {
        make TWiki::FormattedText.new(
            delimiter => '`',
            text      => ~$<text>
        );
    }

    method span($/) {
        make TWiki::HTMLSpan.new(
            html => ~$/
        );
    }

    method normal-word($/) {
        make TWiki::PlainText.new(~$/);
    }

    method block-image($/) {
        my %attributes;
        %attributes.append: $<attribute>.list».ast;

        make TWiki::Image.new(
            | %attributes
        );
    }

    method list-items($/) {
        make TWiki::List.new(
            items => $<item>».ast
        );
    }

    method list-item($/) {
        # The matches hash here contains just a single element because it's an
        # alternative, so take it.
        make $/[0].hash.values[0].ast;
    }

    method list-text($/) {
        make TWiki::Text.new(
            elements => $<text-span>[0].ast
        )
    }

    method list-bullet($/) {
        make TWiki::BulletListItem.new(
            text => $<list-text>.ast
        );
    }

    method list-numbered($/) {
        make TWiki::NumberedListItem.new(
            text => $<list-text>.ast
        );
    }

    method list-def($/) {
        make TWiki::DefListItem.new(
            name => ~$<name>,
            text => ~$<text>,
        );
    }

    method html-fragment($/) {
        make TWiki::HTMLFragment.new(
            html => ~$/
        );
    }

    method header($/) {
        # Header may not have any text, making it rather useless, so skip it.
        my $text = $/<text-span>;
        return unless $text;

        make TWiki::Header.new(
            level => $/<level>.chars,
            text  => TWiki::Text.new(
                elements => $text.ast
            )
        );
    }

    method header-row($/) {
        make $/<header-cell>».ast;
    }

    method header-cell($/) {
        # There are some empty header cells too.
        my $text = $/<value>;
        make $text ?? ~$text !! '';
    }

    method table-row($/) {
        make TWiki::TableRow.new(
            cells => $/<cell>».Str
        );
    }

    method table($/) {
        make TWiki::Table.new(
            headers => defined($/<header-row>) ?? $/<header-row>.ast !! [],
            rows    => $/<table-row>».ast
        );
    }

    method text-span($/) {
        # Text span contains a single multiple match represented by an array
        # whose elements are single-element hashes, so flatten them.
        #
        # The grammar structure probably could (should?) be reorganized to
        # simplify this.
        my @elements;
        for $/[0] -> $single-element {
            my $span = $single-element.hash.values;
            if $span.elems != 1 {
                note "Unexpected span AST structure when parsing $.file: { $span.perl }";
            }

            @elements.push: $span[0].ast;
        }

        make @elements;
    }

    method normal-text($/) {
        make TWiki::Text.new(
            elements => $<text-span>.ast
        );
    }
}

sub MAIN(*@twiki-files, Str :$out-dir, Bool :$debug, Bool :$stop-on-first-error) {
    # Process command-line arguments and read the input files.
    sub log-debug($msg) {
        note $msg if $debug;
    }

    if $out-dir {
        $out-dir.IO.mkdir;
    }

    my $rc = 0;
    for @twiki-files -> $twiki-file {
        my $input = $twiki-file.IO.slurp;

        my $actions = TWiki::Actions.new(file => $twiki-file);
        my $result = try TWiki::Grammar.parse($input, :actions($actions)).ast;
        if ! $result {
            note "Failed to parse $twiki-file as TWiki page.";
            note $! if $!;

            $rc = 1;

            last if $stop-on-first-error;
        } else {
            log-debug $result;

            if $out-dir {
                try {
                    $out-dir.IO.add(
                        get-name-from-twiki-file($twiki-file) ~ '.adoc'
                    ).spurt: $result.to-adoc
                }

                if $! {
                    note "Failed to convert $twiki-file to Asciidoc: $!\n{ $!.backtrace }";
                    $rc = 2;

                    last if $stop-on-first-error;
                }
            }
        }
    }

    exit $rc
}
